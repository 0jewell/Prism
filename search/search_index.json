{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Prism is a powerful and flexible Entity Component System (ECS) library designed for efficient game development in Roblox. It enables a data-driven approach to managing entities and their behaviors.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>This is a rework of Celesta, my old ECS library, created a couple months ago. After having some problems with Celesta development, I stopped it and now I decided to open-source the new version of it with a new name -- Prism.</p>"},{"location":"#usage","title":"Usage","text":"<pre><code>local world = require(shared.world)\n\nlocal health = world.spawn()\nlocal damaged = world.spawn()\n\nlocal entity = world.spawn()\nworld.insert(entity, health, 100)\nworld.insert(entity, damaged, 10)\n\nworld.query(health, damaged) (function(entity)\n    local health, damaged = world.get(entity, health, damaged)\n\n    world.insert(entity, health, math.max(0, health - damaged)\n    world.remove(entity, damaged)\nend)\n</code></pre>"},{"location":"Concepts/Entities/","title":"Entities and components","text":"<p>Entities are unique identifiers that act as containers for components, defining their data and state. Entities do not store logic or behavior directly; instead, traits (systems) operate on entities based on their assigned components.</p> <pre><code>local entity = world.spawn()\n</code></pre>"},{"location":"Concepts/Entities/#components","title":"Components","text":"<p>To first understand components, you need to understand that: components are also entities.</p> <p>In most ECS libraries, every component is simply an entity used as a label or identifier for data. When you create something like <code>health</code> or <code>player</code>, you're just creating an entity that serves a specific role in context.</p> <p>The distinction between an \"entity\" and a \"component\" is entirely semantic and contextual:</p> <ul> <li>When an entity is used to store data, tags, or relationships inside another entity, we call it a component.</li> <li>When it's used as a standalone game object (like a player, enemy, or projectile), we refer to it as a primary entity.</li> </ul> <pre><code>local player = world.spawn() -- 'player' is a game object\nlocal health = world.spawn() -- 'health' is a component\nworld.insert(player, health, 100) -- Here, 'health' acts as a component\n</code></pre> <p>Because components are just identifiers, you could technically assign any entity to another \u2014 even the same one: <pre><code>world.insert(player, player, player)\n</code></pre></p> <p>This works because the world treats the second parameter (<code>player</code>) as the component label, and the third as the value being associated. What matters is not what the entity \"is,\" but how it's used.</p>"},{"location":"Concepts/Entities/#use-cases","title":"Use cases","text":"<p>In general component is simple a information that is added to an entity. They can serve various purposes such as:</p> <ul> <li> <p>Serving as simple tags (e.g., \"this entity is a <code>player</code>\"). <pre><code>local player = world.spawn()\nworld.insert(entity, player)\n</code></pre></p> </li> <li> <p>Holding structured data (e.g., \"this entity has <code>health</code> with a maximum of <code>100</code>\"). <pre><code>local health = world.spawn()\nlocal data = { max = 100, current = 100 }\nworld.insert(entity, health, data)\n</code></pre></p> </li> </ul> <p>Tip</p> <p>We recommend you to check this page on typing your components data.</p>"},{"location":"Concepts/Traits/","title":"Traits","text":"<p>Traits define the behavior of entities by operating on entities that contain specific components. They act as systems that process and modify entity states dynamically.</p>"},{"location":"Concepts/Traits/#understading-them","title":"Understading them","text":"<p>A Trait is not a loop or a frame-based system. It runs exactly once when an entity first matches the component requirements specified in the query.</p> <pre><code>local entity = world.spawn()\nlocal health = world.spawn()\n\nlocal counter = 0\n\nworld.query(health) (function(entity)\n    print('This is the', counter, 'time')\n    counter += 1\nend)\n\nworld.insert(entity, health, 100) --&gt; this is the 1 time\n</code></pre> <p>Reactive, not continuous</p> <p>Traits are reactive. They only execute once per matching event. They do not run every frame, and they do not loop over entities continuously. Think of them as event-driven systems triggered by changes in the entity's state.</p> <p>If the entity stops matching (e.g., a required component is removed), the trait is automatically removed. If it later matches again, the trait is re-applied, and the function is executed again once.</p> <pre><code>world.remove(entity, health)\n\nworld.insert(entity, health, { value = 50 }) --&gt; this is the 2 time\n</code></pre>"},{"location":"Concepts/Traits/#trait-cleanup","title":"Trait Cleanup","text":"<p>When writing traits that create or manage instances or resources, it's important to manually add them to the cleaning scope.</p> <pre><code>local components = require(path.to.components)\nlocal part = components.part\n\nreturn function(world)\n    world.query(part) (function(entity, clean)\n        local instance = Instance.new('Part', workspace)\n        clean(instance)\n\n        world.insert(entity, part, instance)\n    end)\nend\n</code></pre> <p>Modular Code</p> <p>Separating your queries in modules allows for a cleaner codebase. From now on, we will follow this approach.</p>"},{"location":"Examples/Fusion/","title":"Using Fusion with Prism","text":"<p>This example shows how to use fusion states in components data.</p>"},{"location":"Examples/Fusion/#overview","title":"Overview","text":"<p>Assuming the following code:</p> shared/world.luau<pre><code>local packages = game.ReplicatedStorage.packages\nlocal prism = require(packages.prism)\n\nreturn prism.world.new()\n</code></pre> shared/components.luau<pre><code>local packages = game.ReplicatedStorage.packages\nlocal shared = game.ReplicatedStorage.shared\n\nlocal fusion = require(packages.fusion)\ntype value&lt;T&gt; = fusion.value&lt;T&gt;\n\nlocal prism = require(packages.prism)\ntype entity&lt;T&gt; = prism.entity&lt;T&gt;\n\nlocal world = require(shared.world)\n\nreturn {\n    health = world.spawn() :: entity&lt;{\n       max: number,\n        current: value&lt;number&gt;\n    }&gt;\n}\n</code></pre> <p>And then on your system:</p> <pre><code>local packages = game.ReplicatedStorage.packages\nlocal shared = game.ReplicatedStorage.shared\n\nlocal fusion = require(packages.fusion)\nlocal scoped = fusion.scoped\nlocal peek = fusion.peek\nlocal hydrate = fusion.Hydrate\nlocal computed = fusion.Computed\n\nlocal world = require(shared.world)\nlocal components = require(shared.components)\n\nlocal health_bar = Instance.new('Frame')\nlocal blood_vignette = Instance.new('Frame')\n\nworld.query(client, health) (function(entity, clean)\n    local health = world.get(entity, health)\n    local current = health.current\n    local max = health.max\n\n    local scope = scoped()\n    clean(scope)\n\n    hydrate(scope, health_bar) {\n        Size = computed(function(use)\n            local percent = use(current) / max\n\n            return UDim2.fromScale(percent, 1)\n        end)\n    }\nend)\n</code></pre>"},{"location":"Getting-started/","title":"Getting Started","text":"<p>To start a new project with Prism, you'll need to create a <code>world</code> and set up your traits. First, import Prism and create your world:</p> shared/world.luau<pre><code>local prism = require(ReplicatedStorage.prism)\n\nlocal world = prism.world()\n\nreturn world\n</code></pre>"},{"location":"Getting-started/#create-your-components","title":"Create your components","text":"<p>Next, define your components module</p> shared/components.luau<pre><code>local world = require(shared.world)\n\nreturn {\n    alive = world.spawn(),\n    energy = world.spawn()\n}\n</code></pre> <p>Tip</p> <p>Check this guide to type your components data</p>"},{"location":"Getting-started/#add-a-trait-to-the-world","title":"Add a trait to the world","text":"<p>Then, define a behavior to your entities</p> systems/energy.luau<pre><code>local world = require(shared.world)\n\nlocal components = require(shared.components)\nlocal alive, energy = components.alive, components.energy\n\nworld.query(alive, energy) (function(entity, clean)\n    -- regenerate 1 energy every second\n    local loop = task.spawn(function()\n        while task.wait(1) do\n            local energy = world.get(entity, energy)\n            world.insert(entity, math.min(100, energy + 1))\n        end\n    end)\n\n    -- cleanup coroutine on remove\n    clean(function() task.cancel(loop) end)\nend)\n\nreturn nil\n</code></pre>"},{"location":"Getting-started/#create-an-entity","title":"Create an entity","text":"<p>Now, create an entity with some initial energy and the <code>alive</code> component</p> <pre><code>local player = world.spawn()\nworld.insert(player, energy, 50)\nworld.insert(player, alive, true)\n</code></pre>"},{"location":"Getting-started/#next-steps","title":"Next steps","text":"<p>You can continue by:</p> <ul> <li>Defining more components like Health, Speed, Burning, etc.</li> <li>Creating more complex systems like damage over time, status effects, or AI behavior</li> <li>Exploring the internals of the world, query, and assign APIs</li> </ul>"},{"location":"Guides/Collection-service/","title":"Using Prism with CollectionService","text":"<p>Roblox's <code>CollectionService</code> lets you tag instances in the Explorer, making it possible to reference those instances in your code.</p> <p>This is useful when you are working with objects that are already placed in the scene, such as doors, trees, or anything else you may use on your map.</p>"},{"location":"Guides/Collection-service/#what-this-does","title":"What this does?","text":"<ul> <li>You can create entities for those static objects</li> <li>You can add functionality to them using Prism</li> </ul>"},{"location":"Guides/Collection-service/#example-code","title":"Example code","text":"shared/tag.luau<pre><code>local CollectionService = game:GetService('CollectionService')\n\nlocal components = require(shared.components)\nlocal instance = components.instance\n\n-- internal tag-to-component map\nlocal tags = {}\n\n-- pawns an entity and attaches components to it\nlocal function spawn_bound(\n    instance: Instance,\n    component: entity\n)\n    local entity = world.spawn()\n    world.insert(entity, component)\n    world.insert(entity, instance, instance)\n\n    instance:SetAttribute('id', id)\nend\n\n-- loads a collection tag as a component\nlocal function load_collection(tag: string): entity\n    if tags[tag] then return tags[tag] end\n\n    local tag_component = world.spawn()\n    tags[tag] = tag_component\n\n    local function on_added(instance)\n        spawn_bound(instance, tag_component)\n    end\n    CollectionService:GetInstanceAddedSignal(tag):Connect(on_added)\n\n    local function on_removed(instance)\n        local id = instance:GetAttribute('serverid')\n        if id then\n            world.despawn(id)\n        end\n    end\n    CollectionService:GetInstanceRemovedSignal(tag):Connect(on_removed)\n\n    for _, instance in CollectionService:GetTagged(tag) do\n        spawn_bound(instance, tag_component)\n    end\n\n    return tag_component\nend\n\nreturn load_collection\n</code></pre>"},{"location":"Guides/Collection-service/#usage","title":"Usage","text":"<pre><code>local tag = require(shared.tag)\nlocal killpart = tag('Killpart')\n\nworld.query(killpart, instance) (function(entity, clean)\n    local instance = world.get(entity, instance)\n\n    local connection = instance.Touched:Connect(function(touch)\n        -- kill logic\n    end)\n    clean(connection)\nend)\n</code></pre>"},{"location":"Guides/Strict-typing/","title":"Strict typing","text":""},{"location":"Guides/Strict-typing/#type-notations","title":"Type notations","text":"<p>Programming without guidance can be difficult and frustrating. If you often find yourself opening 2 Visual Studio Code tabs or perhaps constantly switching files on Studio to look at type definitions, that's usually a sign that something is not quite right.</p> <p>In Luau, it is possible to add type annotations to variables, return types and parameters. And when type annotations get too complex, the type inference simple won't work anymore, or it will default to <code>any</code>.</p> <pre><code>local var: number = 10\n\nlocal function func(): number\n    return var\nend\n</code></pre>"},{"location":"Guides/Strict-typing/#how-to-type-components","title":"How to type components","text":"<p>Components are just numbers, aren't they? Well, that's technically correct. But the type checker does not need to know that. In other words, you can simulate the component's type by annotating it as a table, with a fake field holding its type.</p> <pre><code>local world = require(path.to.world)\ntype entity&lt;T&gt; = world.entity&lt;T&gt;\n\ntype health_data = entity&lt;{\n    max: number,\n    current: number\n}&gt;\nlocal health = world.spawn() :: health_data\n</code></pre> <p>In this code, <code>health</code> is typed as:</p> <pre><code>_t: {\n    max: number,\n    current: number\n}\n</code></pre> <p>But in reality, it is a number.</p>"},{"location":"Guides/Strict-typing/#getting-component-data","title":"Getting component data","text":"<p>You can get full type check support when asking for data using a typed component:</p> <pre><code>local entity = world.spawn()\n\nworld.insert(entity, health, {\n    max = 100,\n    current = 100\n})\n\nlocal health_data = world.get(entity, health) --&gt; data is typed\n</code></pre>"},{"location":"Tutorials/Importing/","title":"Importing Prism","text":"<p>After downloading Prism, it should be in a <code>Packages</code> folder on <code>ReplicatedStorage</code>.</p> <p>When using Prism as a variable in your code, it contains a dictionary with the following structure:</p> Prism.luau<pre><code>return {\n    world = require('@self/world'),\n    archetype = require('@self/archetype'),\n    clean = require('@self/clean')\n}\n</code></pre>"},{"location":"Tutorials/Installing/","title":"Installing Prism","text":""},{"location":"Tutorials/Installing/#with-wally-recommended","title":"with Wally recommended","text":"<p>In your <code>wally.toml</code>, add the following line to your dependencies. <pre><code>prism = \"0jewell/prism@0.2.1\"\n</code></pre></p>"},{"location":"Tutorials/Why-ECS/","title":"Why Use ECS (and Why Prism)","text":"<p>In traditional game code, you often attach behavior directly to objects like models or parts. For example, you might write a script inside an NPC model that controls how it moves. This works for small games, but as things grow, this approach gets harder to manage.</p> <p>You might end up with lots of duplicate code and objects that depend too much on each other. Logic becomes scattered across scripts and folders, which leads to difficult bugs when objects interact in unexpected ways.</p> <p>ECS (Entity Component System) is a different way to organize game logic. Instead of putting code inside objects, you separate data (components) from behavior (systems). This gives you more control over how things behave, makes debugging easier, produces faster and more scalable code, and lets you reuse systems for AI, movement, damage, and more.</p>"},{"location":"Tutorials/Why-ECS/#what-is-ecs","title":"What is ECS?","text":"<p>ECS is made of three parts: Entities, which are just IDs (numbers) that don\u2019t hold data themselves; Components, which are simple data attached to entities, such as <code>Health</code>, <code>Position</code>, or <code>Velocity</code>; and Systems, which are functions that run over entities with specific components.</p> <p>You can think of it like this: instead of doing something like assigning <code>Health</code> and <code>Position</code> directly to an NPC and calling its Move method,</p> <pre><code>-- instead of doing this:\nnpc.Health = 50\nnpc.Position = Vector3.new(0, 5, 0)\nnpc:Move()\n</code></pre> <p>you spawn an entity in the world and insert components like <code>Health</code> and <code>Position</code> for that entity.</p> <pre><code>-- you do this:\nlocal entity = world.spawn()\nworld.insert(entity, Health, 50)\nworld.insert(entity, Position, Vector3.new(0, 5, 0))\n</code></pre> <p>Then a trait somewhere else processes all entities that have <code>Position</code> and <code>Velocity</code> components and moves them accordingly.</p>"},{"location":"Tutorials/Why-ECS/#why-use-prism","title":"Why Use Prism?","text":"<p>Prism is a simple and efficient ECS system written for Roblox. It\u2019s designed for games where you want clean, organized logic and need to track state across many objects. It offers good performance without complex boilerplate.</p>"},{"location":"Tutorials/Why-ECS/#reactive-design","title":"Reactive Design","text":"<p>Prism is reactive, which means you can write traits that respond when entities are created or changed. You don\u2019t have to loop through all entities every frame unless you want to.</p> <p>This is useful for objects that should react when spawned, like playing an animation or starting movement, or for logic that only needs to run once, such as setting up a health bar. Prism helps make your code modular and event-based, and it integrates well with reactive libraries like Fusion or Vide.</p>"},{"location":"Tutorials/Why-ECS/#when-is-ecs-useful","title":"When is ECS Useful?","text":"<p>You probably don\u2019t need ECS for a game with only a few objects and one enemy. But if your game has many enemies, different systems like AI, health, movement, status effects, dynamically created objects, server-side state, or logic that repeats across different parts of the game, ECS will make development easier.</p>"}]}