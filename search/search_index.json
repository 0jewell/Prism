{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Prism is a powerful and flexible Entity Component System (ECS) library designed for efficient game development in Roblox. It enables a data-driven approach to managing entities and their behaviors.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>This is a rework of Celesta, my old ECS library, created a couple months ago. After having some problems with Celesta development, I stopped it and now I decided to open-source the new version of it with a new name -- Prism.</p>"},{"location":"#usage","title":"Usage","text":"<pre><code>local world = require(shared.world)\n\nlocal health = world:spawn()\nlocal damaged = world:spawn()\n\nlocal entity = world:spawn()\n\nworld:insert(entity,\n    health, 100,\n    damaged, 10\n)\n\nworld:query(health, damaged) (function(entity)\n    local health = world:ask(entity, health)\n    local damaged = world:ask(entity, damaged)\n\n    world:assign(entity, health, math.max(0, health - damaged)\n\n    world:remove(entity, damaged)\nend)\n</code></pre>"},{"location":"Concepts/Entities/","title":"Entities and components","text":"<p>Entities are unique identifiers that act as containers for components, defining their data and state. Entities do not store logic or behavior directly; instead, Traits (systems) operate on entities based on their assigned components.</p>"},{"location":"Concepts/Entities/#_1","title":"Entities","text":"<pre><code>local entity = world:spawn()\n</code></pre>"},{"location":"Concepts/Entities/#components","title":"Components","text":"<p>To first understand components, you need to understand that: components are also entities.</p> <p>In most ECS libraries, every component is simply an entity used as a label or identifier for data. When you create something like <code>health</code> or <code>player</code>, you're just creating an entity that serves a specific role in context.</p> <p>The distinction between an \"entity\" and a \"component\" is entirely semantic and contextual:</p> <ul> <li>When an entity is used to store data, tags, or relationships inside another entity, we call it a component.</li> <li>When it's used as a standalone game object (like a player, enemy, or projectile), we refer to it as a primary entity.</li> </ul> <pre><code>local player = world:spawn() -- 'player' is a game object\nlocal health = world:spawn() -- 'health' is a component\nworld:assign(player, health, 100) -- Here, 'health' acts as a component\n</code></pre> <p>Because components are just identifiers, you could technically assign any entity to another \u2014 even the same one: <pre><code>world:assign(player, player, player)\n</code></pre></p> <p>This works because the world treats the second parameter (<code>player</code>) as the component label, and the third as the value being associated. What matters is not what the entity \"is,\" but how it's used.</p>"},{"location":"Concepts/Entities/#use-cases","title":"Use cases","text":"<p>In general component is simple a information that is added to an entity. They can serve various purposes such as:</p> <ul> <li> <p>Serving as simple tags (e.g., \"this entity is a <code>player</code>\"). <pre><code>local player = world:spawn()\nworld:assign(entity, player)\n</code></pre></p> </li> <li> <p>Holding structured data (e.g., \"this entity has <code>health</code> with a maximum of <code>100</code>\"). <pre><code>local health = world:spawn()\nlocal data = { max = 100, current = 100 }\nworld:assign(entity, health, data)\n</code></pre></p> </li> </ul>"},{"location":"Concepts/Traits/","title":"Traits","text":"<p>Traits define the behavior of entities by operating on entities that contain specific Pieces. They act as systems that process and modify entity states dynamically.</p>"},{"location":"Concepts/Traits/#understading-them","title":"Understading them","text":"<p>A Trait is executed whenever an entity matches the required components specified in a query.</p> <pre><code>local entity = world:spawn()\nlocal health = world:spawn()\n\nworld:insert(entity, health, 100)\n\nlocal counter = 1\n\nworld:query(health) (function(entity, scope)\n    print('This is the', counter, 'time')\n    counter += 1\nend)\n--&gt; this is the 1 time\n</code></pre> <p>Note</p> <p>When a query is created in runtime, every entity that matches it will be applied. This mean you can can insert components before actually creating any systems</p> <p>If the entity no longer meets the requirements, the trait is removed. If it later meets the conditions again, the trait is reapplied.</p> <pre><code>world:remove(entity, health)\n\nworld:insert(entity, health, { value = 50 })\n-- &gt; This is the 2 time\n</code></pre>"},{"location":"Concepts/Traits/#trait-cleanup","title":"Trait Cleanup","text":"<p>When writing traits that create or manage instances or resources, it's important to manually clean them up when the trait no longer applies.</p> <pre><code>local components = require(path.to.components)\nlocal part = components.part\n\nreturn function(world)\n    world:query(part) (function(entity, scope)\n        local instance = Instance.new('Part')\n        table.insert(scope, instance)\n\n        world:assign(entity, part, instance)\n    end)\nend\n</code></pre> <p>Modular Code</p> <p>Separating your queries in modules allows for a cleaner codebase. From now on, we will follow this approach.</p>"},{"location":"Examples/Fusion/","title":"Using Fusion with Prism","text":"<p>This example shows how to use Fusion states in pieces data.</p>"},{"location":"Examples/Fusion/#overview","title":"Overview","text":"<pre><code>local Packages = game.ReplicatedStorage.Packages\n\nlocal Fusion = require(Packages.Fusion)\nlocal peek = Fusion.peek\nlocal scoped = Fusion.scoped\ntype Value&lt;T&gt; = Fusion.Value&lt;T&gt;\n\nlocal Prism = require(Packages.Prism)\nlocal from = Prism.from\ntype Piece&lt;D&gt; = Prism.Piece&lt;D&gt;\n\nlocal function Valuing(data)\n    local scope = scoped()\n    return from(Fusion.Value, scope, data)\nend\n\ntype healthData = Piece&lt;{ \n    max: number,\n    current: Value&lt;number&gt;\n}&gt;\nlocal health: healthData = Prism.Piece {\n    max = 100,\n    current = Valuing(100)\n}\n\nlocal HealthBar = Instance.new('Frame')\nlocal BloodVignette = Instance.new('Frame')\n\nreturn Prism.Query { query = function() return health end }\n\n:trait('UpdateHealthBar &amp; ScreenState', function(data, health)\n    local current = health.data.current\n    local max = health.data.max\n\n    local scope = Fusion:innerScope(data.cleaning)\n\n    scope:Hydrate(HealthBar) {\n        Size = scope:Computed(function(use)\n            local percent = use(current) / max\n\n            return UDim2.fromScale(percent, 1)\n        end)\n    }\n\n    scope:Observer(current):onChange(function()\n        local newValue = peek(current)\n\n        if newValue &lt;= 50 then\n            BloodVignette.Visible = true\n        else\n            BloodVignette.Visible = false\n        end\n    end)\nend)\n</code></pre>"},{"location":"Tutorials/Importing/","title":"Importing Prism","text":"<p>After downloading Prism, it should be in a <code>Packages</code> folder on <code>ReplicatedStorage</code>.</p> <p>When using Prism as a variable in your code, it contains a dictionary with the following structure:</p> Prism.luau<pre><code>return {\n    world = require(script.world)\n}\n</code></pre> <p>For use outside of Roblox, it contains the following structure:</p> Prism.luau<pre><code>return {\n    world = require('@self/world'),\n    debugger = require('@self/debugger')\n}\n</code></pre>"},{"location":"Tutorials/Installing/","title":"Installing Prism","text":""},{"location":"Tutorials/Installing/#with-wally-recommended","title":"with Wally recommended","text":"<p>In your <code>wally.toml</code>, add the following line to your dependencies. <pre><code>prism = \"0jewell/prism@0.2.0\"\n</code></pre></p>"}]}