{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Prism is a powerful and flexible Entity Component System (ECS) library designed for efficient game development in Roblox. It enables a data-driven approach to managing entities and their behaviors.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>This is a rework of Celesta, my old ECS library, created 7 months ago. After having some problems with Celesta development, I stopped it and now I decided to open-source the new version of it with a new name -- Prism.</p>"},{"location":"#usage","title":"Usage","text":"<pre><code>local Packages = game.ReplicatedStorage.Packages\nlocal Prism = require(Packages.Prism)\n\nlocal health = Prism.Piece {\n    max = 100,\n    current = 100\n}\n\nreturn Prism.Query { query = function() return health end }\n\n:trait('Update Health', function(data, health)\n    -- Code logic here\nend)\n</code></pre>"},{"location":"Concepts/Entities/","title":"Entities and Pieces","text":"<p>Entities are unique identifiers that act as containers for Pieces (components), defining their data and state. Entities do not store logic or behavior directly; instead, Traits (systems) operate on entities based on their assigned Pieces.</p> <pre><code>local entity = Registry:entity()\n</code></pre>"},{"location":"Concepts/Entities/#pieces","title":"Pieces","text":"<p>A Piece is a data container that is added to an entity. Pieces can serve various purposes such as:</p> <ul> <li> <p>Serving as simple tags (e.g., \"this entity is a <code>Player</code>\"). <pre><code>local player = Registry:entity()\n\n--// Entities that are attached to other entities are called Pieces too.\nRegistry:add(entity, player)\n</code></pre></p> </li> <li> <p>Holding structured data (e.g., \"this entity has <code>Health</code> with a maximum of <code>100</code>\"). <pre><code>local health = Piece { maximum = 100 }\nRegistry:add(entity, health)\n</code></pre></p> </li> <li> <p>Creating associations between entities (e.g., \"Enemy is <code>targeting</code> Player\"). <pre><code>local enemy = Registry:entity()\nlocal targeting = Registry:entity()\nlocal player = Registry:entity()\n\nRegistry:add(enemy, Registry:pair(targeting, player))\n</code></pre></p> </li> <li> <p>Optionally storing extra information (e.g., \"Enemy is <code>looking</code> for player within <code>20</code> meters\"). <pre><code>local enemy = Registry:entity()\nlocal looking = Registry:entity()\nlocal player = Registry:entity()\n\nRegistry:add(enemy, Registry:pair(looking, player), { distance = 20 })\n</code></pre></p> </li> </ul>"},{"location":"Concepts/Entities/#pieces-are-entities","title":"Pieces are entities","text":"<p>Since Pieces are the only way to define an entity\u2019s data, every Piece is inherently an entity. When a Piece is created, it automatically becomes an entity within the registry. This mean that all of the API that apply to regular entities also apply to pieces.</p> <pre><code>local Piece = Prism.Piece\n\nlocal health, networked = Piece(...), Piece(...)\nRegistry:add(health, networked)\n</code></pre> <p>In general, Pieces are primarily used to define data structures before runtime. They serve as blueprints for entity composition, ensuring that the necessary attributes are established before the game logic starts executing.</p>"},{"location":"Concepts/Traits/","title":"Traits","text":"<p>Traits define the behavior of entities by operating on entities that contain specific Pieces. They act as systems that process and modify entity states dynamically.</p>"},{"location":"Concepts/Traits/#understading-them","title":"Understading them","text":"<p>A Trait is executed whenever an entity matches the required Pieces specified in its query.</p> <pre><code>local Query = Prism.Query { query = function() return health end }\n\nlocal counting = 1\n\nQuery:trait('Regenerate Health', function(data, health)\n    print('This is the', counting, 'time')\n    counting += 1\nend)\n\nRegistry:include { Query }\n\nRegistry:add(entity, health)\n--&gt; This is the 1 time\n</code></pre> <p>If the entity no longer meets the requirements, the trait is removed. If it later meets the conditions again, the trait is reapplied.</p> <pre><code>Registry:remove(entity, health)\n\nRegistry:add(entity, health)\n--&gt; This is the 2 time\n</code></pre>"},{"location":"Concepts/Traits/#trait-cleanup","title":"Trait Cleanup","text":"<p>Traits can be added or removed dynamically, but removing a trait does not automatically revert changes. You must manually handle the cleanup of any data associated with it.</p> <pre><code>return Prism.Query { query = function() return part end }\n\n    :trait('Create part', function(data, part)\n        local instance = Instance.new('Part')\n\n        -- Store the instance for cleanup when the trait is removed\n        table.insert(data.cleaning, instance)\n\n        part.data.instance = instance\n    end)\n</code></pre> <p>Modular Code</p> <p>Returning queries from modules allows for a cleaner codebase. From now on, we will follow this approach.</p>"},{"location":"Concepts/Traits/#trait-execution-order","title":"Trait Execution Order","text":"<p>A single query can have multiple traits. Traits are executed in the order they are defined within the query.</p> <pre><code>return Prism.Query { query = function() return part end }\n\n    :trait('Create part', function(data, part)\n        local instance = Instance.new('Part')\n\n        -- Store the instance for cleanup when the Trait is removed\n        table.insert(data.cleaning, instance)\n\n        part.data.instance = instance\n    end)\n\n    :trait('Print part', function(data, part)\n        print(part.data.instance)\n        --&gt; 'Part'\n    end)\n</code></pre>"},{"location":"Examples/Fusion/","title":"Using Fusion with Prism","text":"<p>This example shows how to use Fusion states in pieces data.</p>"},{"location":"Examples/Fusion/#overview","title":"Overview","text":"<pre><code>local Packages = game.ReplicatedStorage.Packages\n\nlocal Fusion = require(Packages.Fusion)\nlocal peek = Fusion.peek\nlocal scoped = Fusion.scoped\ntype Value&lt;T&gt; = Fusion.Value&lt;T&gt;\n\nlocal Prism = require(Packages.Prism)\nlocal from = Prism.from\ntype Piece&lt;D&gt; = Prism.Piece&lt;D&gt;\n\nlocal function Valuing(data)\n    local scope = scoped()\n    return from(Fusion.Value, scope, data)\nend\n\ntype healthData = Piece&lt;{ \n    max: number,\n    current: Value&lt;number&gt;\n}&gt;\nlocal health: healthData = Prism.Piece {\n    max = 100,\n    current = Valuing(100)\n}\n\nlocal HealthBar = Instance.new('Frame')\nlocal BloodVignette = Instance.new('Frame')\n\nreturn Prism.Query { query = function() return health end }\n\n:trait('UpdateHealthBar &amp; ScreenState', function(data, health)\n    local current = health.data.current\n    local max = health.data.max\n\n    local scope = Fusion:innerScope(data.cleaning)\n\n    scope:Hydrate(HealthBar) {\n        Size = scope:Computed(function(use)\n            local percent = use(current) / max\n\n            return UDim2.fromScale(percent, 1)\n        end)\n    }\n\n    scope:Observer(current):onChange(function()\n        local newValue = peek(current)\n\n        if newValue &lt;= 50 then\n            BloodVignette.Visible = true\n        else\n            BloodVignette.Visible = false\n        end\n    end)\nend)\n</code></pre>"},{"location":"Tutorials/Importing/","title":"Importing Prism","text":"<p>After downloading Prism, it should be in a <code>Packages</code> folder on <code>ReplicatedStorage</code>.</p> <p>When using Prism as a variable in your code, it contains a dictionary with the following structure:</p> <p>Freezed data</p> <p>The returned table is freezed.</p> Prism.luau<pre><code>local Data = require(script.Modules.Data)\nlocal Clean = require(script.Modules.Clean)\n\nlocal Registry = require(script.Registry)\nlocal Query = require(script.Query)\nlocal Piece = require(script.Piece)\n\nreturn {\n    Registry = Registry.New,\n    Query = Query.New,\n    Piece = Piece.New,\n\n    from = Piece.from,\n\n    MergeData = Data.merge,\n    Clean = Clean\n}\n</code></pre>"},{"location":"Tutorials/Installing/","title":"Installing Prism","text":""},{"location":"Tutorials/Installing/#with-pesde-recommended","title":"with Pesde recommended","text":"<p>In your terminal, run the following command: <pre><code>pesde add 0jewell/prism\n</code></pre></p> <p>Your pesde.toml file should be like this: pesde.toml<pre><code>[dependencies]\nPrism = { name = \"0jewell/prism\", version = \"^0.1.1\" }\n</code></pre></p>"}]}